<script src="../tinytest.js"></script>
<script>

// Prototype implementation:
  // function reduce(array, callback, startingValue) {
  //   var resultSoFar = startingValue;
  //   for (var i = 0; i < array.length; i++) {
  //     resultSoFar = callback(resultSoFar, array[i], i, array);
  //   }
  //   return resultSoFar;
  // }

// Function signature:
  // reduce(array, callback[, initialValue])

// Callback parameters:
  // previousValue (accumulator, resultSoFar) 
  // currentValue (array[i])
  // currentIndex (i)
  // array (original array)

// Return value:
  // Returns a single value.



function reduce(array, callback, initialValue) {

  var startingIndex = 0;
  var resultSoFar = initialValue;

  // No initialValue then startingInd=1
  if (arguments.length < 3) {
    resultSoFar = array[startingIndex];
    startingIndex++;

    // Array has one element then gets the index number
    if (Object.keys(array).length === 1) {
      var singleIndex = Object.keys(array)[0];
    }

  // Has initial Value.
  } else {
    // initialValue exist AND array is empty
    if (Object.keys(array).length === 0){
      // return initialValue and exits w/o callback below
      return initialValue;
    }
  }

  for (var i = startingIndex; i < array.length; i++) {
    callback(resultSoFar, array[i], i);
  }

}

tests({
  'If initialValue, callback should run array.length times.': function() {
    var numberOfTimesCallbackHasRun = 0;
    reduce([1], function() {
      numberOfTimesCallbackHasRun++;
    }, 0)
    eq(numberOfTimesCallbackHasRun, 1);
  },
  'If no initialValue, callback should run array.length - 1 times': function() {
    var numberOfTimesCallbackHasRun = 0;
    reduce([1], function() {
      numberOfTimesCallbackHasRun++;
    });
    eq(numberOfTimesCallbackHasRun, 0);
  },

  'If intialValue, previousValue(accumulator) should start with initialValue.': function() {
    reduce([1], function(previousValue) {
      eq(previousValue, 0);
    }, 0);
  },
  'If initialValue, currentValue should start with array[0].': function() {
    reduce([1], function(previousValue, currentValue) {
      eq(currentValue, 1);
    }, 0);
  },
  'If initialValue, callback will start at index 0.': function() {
    reduce([1], function(previousValue, currentValue, currentIndex) {
      eq(currentIndex, 0);
    }, 0);
  },

  'If no initialValue, previousValue (accumulator) should start with array[0].': function() {
    reduce([1, 2], function(previousValue) {
      eq(previousValue, 1);
    });
  },
  'If no initialValue, currentValue should start with array[1].': function() {
    reduce([1, 2], function(previousValue, currentValue) {
      eq(currentValue, 2);
    });
  },
  'If no initialValue, callback will start at index 1.': function() {
    reduce([1, 2], function(previousValue, currentValue, currentIndex) {
      eq(currentIndex, 1);
    });
  },

  'If initialValue, and array is empty, return intialValue without calling callback.': function() {
    var numberOfTimesCallbackHasRun = 0;
    var initialValue = 0;
    var reduceResult =  reduce([,,], function() {
      // this callback should not run just for testing that
      numberOfTimesCallbackHasRun++;
    }, initialValue);
    eq(reduceResult, initialValue);
    eq(numberOfTimesCallbackHasRun, 0);
  },
  'If no initialValue, and array has one element, it should return that element without calling callback.': function() {
    var numberOfTimesCallbackHasRun = 0;
    var reduceResult = reduce([1], function() {
      numberOfTimesCallbackHasRun++;
    });
    eq(reduceResult, 1);
    eq(numberOfTimesCallbackHasRun, 0);
  },

  'It should actually reduce.': function() {
    fail();
  },
  'It should exclude holes.': function() {
    fail();
  },
  'If array is empty and no initialValue, throw TypeError.': function() {
    fail();
  },
  'It should pass array as fourth argument to callback.': function() {
    fail();
  }
});



</script>
